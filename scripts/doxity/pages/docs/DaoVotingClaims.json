{"author":"Digix Holdings","title":"Contract to claim voting results","fileName":"/contracts/interactive/DaoVotingClaims.sol","name":"DaoVotingClaims","abi":[{"constant":true,"inputs":[],"name":"resolver","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","outputs":[{"name":"_quarterIndex","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","outputs":[{"name":"_config_value","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","outputs":[{"name":"_config_value","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"key","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_index","type":"uint256"},{"name":"_operations","type":"uint256"}],"name":"claimProposalVotingResult","outputs":[{"name":"_passed","type":"bool"},{"name":"_done","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","outputs":[{"name":"_config_value","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"currentTInQuarter","outputs":[{"name":"_currentT","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_count","type":"uint256"}],"name":"claimDraftVotingResult","outputs":[{"name":"_passed","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"pendingOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_resolver","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"}],"name":"OwnershipRenounced","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/ownership/Claimable.sol\";\nimport \"../common/DaoCommon.sol\";\nimport \"../service/DaoCalculatorService.sol\";\nimport \"./DaoFundingManager.sol\";\nimport \"./DaoRewardsManager.sol\";\nimport \"../lib/DaoIntermediateStructs.sol\";\nimport \"../lib/DaoStructs.sol\";\n\n/**\n@title Contract to claim voting results\n@author Digix Holdings\n*/\ncontract DaoVotingClaims is DaoCommon, Claimable {\n    using DaoIntermediateStructs for DaoIntermediateStructs.VotingCount;\n    using DaoIntermediateStructs for DaoIntermediateStructs.MilestoneInfo;\n    using DaoIntermediateStructs for DaoIntermediateStructs.Users;\n    using DaoStructs for DaoStructs.IntermediateResults;\n\n    function daoCalculatorService()\n        internal\n        constant\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    function daoFundingManager()\n        internal\n        constant\n        returns (DaoFundingManager _contract)\n    {\n        _contract = DaoFundingManager(get_contract(CONTRACT_DAO_FUNDING_MANAGER));\n    }\n\n    function daoRewardsManager()\n        internal\n        constant\n        returns (DaoRewardsManager _contract)\n    {\n        _contract = DaoRewardsManager(get_contract(CONTRACT_DAO_REWARDS_MANAGER));\n    }\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_DAO_VOTING_CLAIMS, _resolver));\n    }\n\n    /**\n    @notice Function to claim the draft voting result (can only be called by the proposal proposer)\n    @param _proposalId ID of the proposal\n    @param _count Number of operations to do in this call\n    @return {\n      \"_passed\": \"Boolean, true if the draft voting has passed, false if the claiming deadline has passed, revert otherwise\"\n    }\n    */\n    function claimDraftVotingResult(\n        bytes32 _proposalId,\n        uint256 _count\n    )\n        public\n        ifDraftNotClaimed(_proposalId)\n        ifAfterDraftVotingPhase(_proposalId)\n        returns (bool _passed)\n    {\n\n        // if after the claiming deadline, its auto failed\n        if (now > daoStorage().readProposalDraftVotingTime(_proposalId)\n                    .add(get_uint_config(CONFIG_DRAFT_VOTING_PHASE))\n                    .add(get_uint_config(CONFIG_VOTE_CLAIMING_DEADLINE))) {\n            daoStorage().setProposalDraftPass(_proposalId, false);\n            daoStorage().setDraftVotingClaim(_proposalId, true);\n            handleRefundCollateral(_proposalId);\n            return false;\n        }\n        require(isFromProposer(_proposalId));\n        senderCanDoProposerOperations();\n        checkNonDigixProposalLimit(_proposalId);\n\n\n        // get the previously stored intermediary state\n        DaoStructs.IntermediateResults memory _currentResults;\n        (\n            _currentResults.countedUntil,\n            _currentResults.currentForCount,\n            _currentResults.currentAgainstCount,\n            _currentResults.currentQuorum,\n        ) = intermediateResultsStorage().getIntermediateResults(_proposalId);\n\n        // get first address based on intermediate state\n        address[] memory _moderators;\n        if (_currentResults.countedUntil == EMPTY_ADDRESS) {\n            _moderators = daoListingService().listModerators(\n                _count,\n                true\n            );\n        } else {\n            _moderators = daoListingService().listModeratorsFrom(\n               _currentResults.countedUntil,\n               _count,\n               true\n           );\n        }\n\n        // get moderators\n        address _moderator = _moderators[_moderators.length-1];\n\n        // count the votes for this batch of moderators\n        DaoIntermediateStructs.VotingCount memory _voteCount;\n        (_voteCount.forCount, _voteCount.againstCount, _voteCount.quorum) = daoStorage().readDraftVotingCount(_proposalId, _moderators);\n\n        _currentResults.countedUntil = _moderator;\n        _currentResults.currentForCount = _currentResults.currentForCount.add(_voteCount.forCount);\n        _currentResults.currentAgainstCount = _currentResults.currentAgainstCount.add(_voteCount.againstCount);\n        _currentResults.currentQuorum = _currentResults.currentQuorum.add(_voteCount.quorum);\n\n        if (_moderator == daoStakeStorage().readLastModerator()) {\n            // this is the last iteration\n            _passed = true;\n            processDraftVotingClaim(_proposalId, _currentResults);\n\n            // reset intermediate result for the proposal\n            intermediateResultsStorage().resetIntermediateResults(_proposalId);\n        } else {\n            // update intermediate results\n            intermediateResultsStorage().setIntermediateResults(\n                _proposalId,\n                _currentResults.countedUntil,\n                _currentResults.currentForCount,\n                _currentResults.currentAgainstCount,\n                _currentResults.currentQuorum,\n                0\n            );\n        }\n    }\n\n    function processDraftVotingClaim(bytes32 _proposalId, DaoStructs.IntermediateResults _currentResults)\n        internal\n    {\n        if (\n            (_currentResults.currentQuorum > daoCalculatorService().minimumDraftQuorum(_proposalId)) &&\n            (daoCalculatorService().draftQuotaPass(_currentResults.currentForCount, _currentResults.currentAgainstCount))\n        ) {\n            daoStorage().setProposalDraftPass(_proposalId, true);\n\n            // set startTime of first voting round\n            // and the start of first milestone.\n            uint256 _idealClaimTime = daoStorage().readProposalDraftVotingTime(_proposalId).add(get_uint_config(CONFIG_DRAFT_VOTING_PHASE));\n            daoStorage().setProposalVotingTime(\n                _proposalId,\n                0,\n                getTimelineForNextVote(0, _idealClaimTime)\n            );\n        } else {\n            handleRefundCollateral(_proposalId);\n        }\n\n        daoStorage().setDraftVotingClaim(_proposalId, true);\n    }\n\n    /// NOTE: Voting round i-th is before milestone index i-th\n\n    /**\n    @notice Function to claim the  voting round results (can only be called by the proposer)\n    @param _proposalId ID of the proposal\n    @param _index Index of the  voting round\n    @param _operations Number of operations to do in this call\n    @return {\n      \"_passed\": \"Boolean, true if the  voting round passed, false if failed\"\n    }\n    */\n    function claimProposalVotingResult(bytes32 _proposalId, uint256 _index, uint256 _operations)\n        public\n        ifNotClaimed(_proposalId, _index)\n        ifAfterProposalRevealPhase(_proposalId, _index)\n        returns (bool _passed, bool _done)\n    {\n        require(isMainPhase());\n        // anyone can claim after the claiming deadline is over;\n        // and the result will be failed by default\n        _done = true;\n        if (now < startOfMilestone(_proposalId, _index)\n                    .add(get_uint_config(CONFIG_VOTE_CLAIMING_DEADLINE)))\n        {\n            (_operations, _passed, _done) = countProposalVote(_proposalId, _index, _operations);\n            if (!_done) return (_passed, false); // haven't done counting yet, return\n        }\n        _done = false;\n\n        if (_index > 0) { // We only need to do bonus calculation if its the interim voting round\n            _done = calculateVoterBonus(_proposalId, _index, _operations, _passed);\n            if (!_done) return (_passed, false);\n        } else {\n            // its the first voting round, we unlock the collateral if it fails, locks if it passes\n            if (_passed) {\n                daoStorage().setProposalCollateralStatus(\n                    _proposalId,\n                    COLLATERAL_STATUS_LOCKED\n                );\n            } else {\n                handleRefundCollateral(_proposalId);\n            }\n\n            checkNonDigixProposalLimit(_proposalId);\n        }\n\n        if (_passed) {\n            allocateFunding(_proposalId, _index);\n        }\n        daoStorage().setVotingClaim(_proposalId, _index, true);\n        daoStorage().setProposalPass(_proposalId, _index, _passed);\n        _done = true;\n    }\n\n    function allocateFunding(bytes32 _proposalId, uint256 _index)\n        internal\n    {\n        uint256 _funding;\n        (, _funding) = daoStorage().readProposalMilestone(_proposalId, _index);\n        uint256[] memory _milestoneFundings;\n        (_milestoneFundings,) = daoStorage().readProposalFunding(_proposalId);\n\n        // if this was the last milestone, unlock their original collateral\n        if ((_index == _milestoneFundings.length) && !isProposalPaused(_proposalId)) {\n            handleRefundCollateral(_proposalId);\n        }\n\n        bool _isDigixProposal;\n        (,,,,,,,,,_isDigixProposal) = daoStorage().readProposal(_proposalId);\n        if (_index == 0 && !_isDigixProposal) {\n            daoStorage().addProposalCountInQuarter(currentQuarterIndex());\n        }\n\n        daoPointsStorage().addQuarterPoint(\n            daoStorage().readProposalProposer(_proposalId),\n            get_uint_config(CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH).mul(_funding).div(10000 ether),\n            currentQuarterIndex()\n        );\n    }\n\n    function calculateVoterBonus(bytes32 _proposalId, uint256 _index, uint256 _operations, bool _passed)\n        internal\n        returns (bool _done)\n    {\n        if (_operations == 0) return false;\n        address _countedUntil;\n        (_countedUntil,,,,) = intermediateResultsStorage().getIntermediateResults(_proposalId);\n\n        address[] memory _voterBatch;\n        if (_countedUntil == EMPTY_ADDRESS) {\n            _voterBatch = daoListingService().listParticipants(\n                _operations,\n                true\n            );\n        } else {\n            _voterBatch = daoListingService().listParticipantsFrom(\n                _countedUntil,\n                _operations,\n                true\n            );\n        }\n        address _lastVoter = _voterBatch[_voterBatch.length - 1]; // this will fail if _voterBatch is empty\n\n        DaoIntermediateStructs.Users memory _bonusVoters;\n        if (_passed) {\n\n            // give bonus points for all those who\n            // voted YES in the previous round\n            (_bonusVoters.users, _bonusVoters.usersLength) = daoStorage().readVotingRoundVotes(_proposalId, _index.sub(1), _voterBatch, true);\n        } else {\n            // give bonus points for all those who\n            // voted NO in the previous round\n            (_bonusVoters.users, _bonusVoters.usersLength) = daoStorage().readVotingRoundVotes(_proposalId, _index.sub(1), _voterBatch, false);\n        }\n        if (_bonusVoters.usersLength > 0) addBonusReputation(_bonusVoters.users, _bonusVoters.usersLength);\n\n        if (_lastVoter == daoStakeStorage().readLastParticipant()) {\n            // this is the last iteration\n\n            intermediateResultsStorage().resetIntermediateResults(_proposalId);\n            _done = true;\n        } else {\n            // this is not the last iteration yet\n            intermediateResultsStorage().setIntermediateResults(_proposalId, _lastVoter, 0, 0, 0, 0);\n        }\n    }\n\n    function countProposalVote(bytes32 _proposalId, uint256 _index, uint256 _operations)\n        internal\n        returns (uint256 _operationsLeft, bool _passed, bool _done)\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n\n        DaoStructs.IntermediateResults memory _currentResults;\n        (\n            _currentResults.countedUntil,\n            _currentResults.currentForCount,\n            _currentResults.currentAgainstCount,\n            _currentResults.currentQuorum,\n        ) = intermediateResultsStorage().getIntermediateResults(_proposalId);\n        address[] memory _voters;\n        if (_currentResults.countedUntil == EMPTY_ADDRESS) {\n            _voters = daoListingService().listParticipants(\n                _operations,\n                true\n            );\n        } else {\n            _voters = daoListingService().listParticipantsFrom(\n                _currentResults.countedUntil,\n                _operations,\n                true\n            );\n\n            // There's no more operations to be done, or there's no voters to count\n            if (_operations == 0 || _voters.length == 0) {\n                return (_operations, false, true);\n            }\n        }\n\n        address _lastVoter = _voters[_voters.length - 1];\n\n        DaoIntermediateStructs.VotingCount memory _count;\n        (_count.forCount, _count.againstCount, _count.quorum) = daoStorage().readVotingCount(_proposalId, _index, _voters);\n\n        _currentResults.currentForCount = _currentResults.currentForCount.add(_count.forCount);\n        _currentResults.currentAgainstCount = _currentResults.currentAgainstCount.add(_count.againstCount);\n        _currentResults.currentQuorum = _currentResults.currentQuorum.add(_count.quorum);\n        intermediateResultsStorage().setIntermediateResults(\n            _proposalId,\n            _lastVoter,\n            _currentResults.currentForCount,\n            _currentResults.currentAgainstCount,\n            _currentResults.currentQuorum,\n            0\n        );\n\n        if (_lastVoter != daoStakeStorage().readLastParticipant()) {\n            return (0, false, false); // hasn't done counting yet\n        }\n\n        // this means all votes have already been counted\n        intermediateResultsStorage().resetIntermediateResults(_proposalId);\n        _operationsLeft = _operations.sub(_voters.length);\n        _done = true;\n\n        if ((_currentResults.currentQuorum > daoCalculatorService().minimumVotingQuorum(_proposalId, _index)) &&\n            (daoCalculatorService().votingQuotaPass(_currentResults.currentForCount, _currentResults.currentAgainstCount)))\n        {\n            _passed = true;\n        }\n    }\n\n    function handleRefundCollateral(bytes32 _proposalId)\n        internal\n    {\n        daoStorage().setProposalCollateralStatus(_proposalId, COLLATERAL_STATUS_CLAIMED);\n        require(daoFundingManager().refundCollateral(daoStorage().readProposalProposer(_proposalId)));\n    }\n\n    function addBonusReputation(address[] _voters, uint256 _n)\n        private\n    {\n        uint256 _qp = get_uint_config(CONFIG_QUARTER_POINT_VOTE);\n        uint256 _rate = get_uint_config(CONFIG_BONUS_REPUTATION_NUMERATOR);\n        uint256 _base = get_uint_config(CONFIG_BONUS_REPUTATION_DENOMINATOR);\n\n        uint256 _bonus = _qp.mul(_rate).mul(get_uint_config(CONFIG_REPUTATION_PER_EXTRA_QP_NUM))\n            .div(\n                _base.mul(get_uint_config(CONFIG_REPUTATION_PER_EXTRA_QP_DEN))\n            );\n\n        for (uint256 i = 0; i < _n; i++) {\n            daoPointsStorage().addReputation(_voters[i], _bonus);\n        }\n    }\n\n}\n","abiDocs":[{"constant":true,"inputs":[],"name":"resolver","payable":false,"stateMutability":"view","type":"function","signature":"resolver()","signatureHash":"04f3bcec"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","payable":false,"stateMutability":"view","type":"function","signature":"currentQuarterIndex()","signatureHash":"0d7cc561"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","payable":false,"stateMutability":"view","type":"function","signature":"get_address_config(bytes32)","signatureHash":"19e971eb"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","payable":false,"stateMutability":"view","type":"function","signature":"get_bytes_config(bytes32)","signatureHash":"217f2412"},{"constant":true,"inputs":[],"name":"key","payable":false,"stateMutability":"view","type":"function","signature":"key()","signatureHash":"3943380c"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_index","type":"uint256","description":"Index of the  voting round"},{"name":"_operations","type":"uint256","description":"Number of operations to do in this call"}],"name":"claimProposalVotingResult","outputs":[{"name":"_passed","type":"bool","description":"Boolean, true if the  voting round passed, false if failed"},{"name":"_done","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"{ \"_passed\": \"Boolean, true if the  voting round passed, false if failed\" }","notice":"Function to claim the  voting round results (can only be called by the proposer)","signature":"claimProposalVotingResult(bytes32,uint256,uint256)","signatureHash":"3d554f39"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32","description":"the resolver key to look up"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address","description":"the address of the contract"}],"payable":false,"stateMutability":"view","type":"function","details":"Get the address of a contract","return":"_contract the address of the contract","signature":"get_contract(bytes32)","signatureHash":"3f83acff"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","payable":false,"stateMutability":"view","type":"function","signature":"get_uint_config(bytes32)","signatureHash":"46b56321"},{"constant":false,"inputs":[],"name":"claimOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows the pendingOwner address to finalize the transfer.","signature":"claimOwnership()","signatureHash":"4e71e0c8"},{"constant":true,"inputs":[],"name":"currentTInQuarter","payable":false,"stateMutability":"view","type":"function","signature":"currentTInQuarter()","signatureHash":"61645b87"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows the current owner to relinquish control of the contract.","notice":"Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore.","signature":"renounceOwnership()","signatureHash":"715018a6"},{"constant":true,"inputs":[],"name":"owner","payable":false,"stateMutability":"view","type":"function","signature":"owner()","signatureHash":"8da5cb5b"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_count","type":"uint256","description":"Number of operations to do in this call"}],"name":"claimDraftVotingResult","outputs":[{"name":"_passed","type":"bool","description":"Boolean, true if the draft voting has passed, false if the claiming deadline has passed, revert otherwise"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"{ \"_passed\": \"Boolean, true if the draft voting has passed, false if the claiming deadline has passed, revert otherwise\" }","notice":"Function to claim the draft voting result (can only be called by the proposal proposer)","signature":"claimDraftVotingResult(bytes32,uint256)","signatureHash":"90e353df"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","payable":false,"stateMutability":"view","type":"function","signature":"isParticipant(address)","signatureHash":"929066f5"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","payable":false,"stateMutability":"view","type":"function","signature":"CONTRACT_ADDRESS()","signatureHash":"db4ecbc1"},{"constant":true,"inputs":[],"name":"pendingOwner","payable":false,"stateMutability":"view","type":"function","signature":"pendingOwner()","signatureHash":"e30c3978"},{"constant":false,"inputs":[{"name":"newOwner","type":"address","description":"The address to transfer ownership to."}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Allows the current owner to set the pendingOwner address.","signature":"transferOwnership(address)","signatureHash":"f2fde38b"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","payable":false,"stateMutability":"view","type":"function","signature":"isProposalPaused(bytes32)","signatureHash":"f94f0f33"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","payable":false,"stateMutability":"view","type":"function","signature":"isModerator(address)","signatureHash":"fa6f3936"},{"inputs":[{"name":"_resolver","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"}],"name":"OwnershipRenounced","type":"event","signature":"OwnershipRenounced(address)","signatureHash":"f8df3114"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event","signature":"OwnershipTransferred(address,address)","signatureHash":"8be0079c"}]}
