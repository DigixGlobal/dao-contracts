{"author":"Digix Holdings","title":"Contract to handle staking/withdrawing of DGDs for participation in DAO","fileName":"/contracts/interactive/DaoStakeLocking.sol","name":"DaoStakeLocking","abi":[{"constant":true,"inputs":[],"name":"resolver","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","outputs":[{"name":"_quarterIndex","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256"}],"name":"lockDGD","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","outputs":[{"name":"_config_value","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"dgdBadgeToken","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","outputs":[{"name":"_config_value","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"key","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","outputs":[{"name":"_config_value","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"currentTInQuarter","outputs":[{"name":"_currentT","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"confirmContinuedParticipation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256"}],"name":"withdrawDGD","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"dgdToken","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"redeemBadge","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_resolver","type":"address"},{"name":"_dgdToken","type":"address"},{"name":"_dgdBadgeToken","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.24;\n\nimport \"@digix/cacp-contracts-dao/contracts/ResolverClient.sol\";\nimport \"../lib/MathHelper.sol\";\nimport \"../common/DaoCommon.sol\";\nimport \"../service/DaoCalculatorService.sol\";\nimport \"./DaoRewardsManager.sol\";\n\n/**\n@title Contract to handle staking/withdrawing of DGDs for participation in DAO\n@author Digix Holdings\n*/\ncontract DaoStakeLocking is DaoCommon {\n\n    address public dgdToken;\n    address public dgdBadgeToken;\n\n    struct StakeInformation {\n        uint256 userActualLockedDGD;\n        uint256 userLockedDGDStake;\n        uint256 totalLockedDGDStake;\n    }\n\n    constructor(address _resolver, address _dgdToken, address _dgdBadgeToken) public {\n        require(init(CONTRACT_DAO_STAKE_LOCKING, _resolver));\n        dgdToken = _dgdToken;\n        dgdBadgeToken = _dgdBadgeToken;\n    }\n\n    function daoCalculatorService()\n        internal\n        constant\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    function daoRewardsManager()\n        internal\n        constant\n        returns (DaoRewardsManager _contract)\n    {\n        _contract = DaoRewardsManager(get_contract(CONTRACT_DAO_REWARDS_MANAGER));\n    }\n\n    /**\n    @notice Function to initially convert DGD Badge to Reputation Points\n    @dev Only 1 DGD Badge is accepted from an address, so multiple badge holders\n         should either sell their other badges or redeem reputation to another address\n    */\n    function redeemBadge()\n        public\n    {\n        // should not have redeemed a badge already\n        require(!daoStakeStorage().redeemedBadge(msg.sender));\n        // should not redeem just before updating last quarter's rewards/reputation\n        // this condition makes sure that the reputation and rewards are at the most updated stage\n        // only exception is, if its their first participation ever\n        require(\n            (daoRewardsStorage().lastParticipatedQuarter(msg.sender) == 0) ||\n            (daoRewardsStorage().lastQuarterThatReputationWasUpdated(msg.sender) == (currentQuarterIndex() - 1))\n        );\n\n        daoStakeStorage().redeemBadge(msg.sender);\n        daoPointsStorage().addReputation(msg.sender, get_uint_config(CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE));\n\n        // update moderator status\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        refreshModeratorStatus(msg.sender, _info, _info);\n\n        // transfer the badge to this contract\n        require(ERC20(dgdBadgeToken).transferFrom(msg.sender, address(this), 1));\n    }\n\n    /**\n    @notice Function to lock DGD tokens to participate in the DAO\n    @dev Users must `approve` the DaoStakeLocking contract to transfer DGDs from them\n    @param _amount Number of DGDs to lock\n    @return {\n      \"_success\": \"Boolean, true if the locking process is successful, false otherwise\"\n    }\n    */\n    function lockDGD(uint256 _amount)\n        public\n        ifNotContract(msg.sender)\n        ifGlobalRewardsSet(currentQuarterIndex())\n        returns (bool _success)\n    {\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        StakeInformation memory _newInfo = refreshDGDStake(msg.sender, _info, false);\n\n        require(_amount > 0);\n        _newInfo.userActualLockedDGD = _newInfo.userActualLockedDGD.add(_amount);\n        uint256 _additionalStake = daoCalculatorService().calculateAdditionalLockedDGDStake(_amount);\n        _newInfo.userLockedDGDStake = _newInfo.userLockedDGDStake.add(_additionalStake);\n        _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.add(_additionalStake);\n\n        daoStakeStorage().updateUserDGDStake(msg.sender, _newInfo.userActualLockedDGD, _newInfo.userLockedDGDStake);\n        daoStakeStorage().updateTotalLockedDGDStake(_newInfo.totalLockedDGDStake);\n        refreshModeratorStatus(msg.sender, _info, _newInfo);\n\n        // This has to happen at least once before user can participate in next quarter\n        daoRewardsManager().updateRewardsBeforeNewQuarter(msg.sender);\n\n        //TODO: there might be a case when user locked in very small amount A that is less than Minimum locked DGD?\n        // then, lock again in the middle of the quarter. This will not take into account that A was staked in earlier\n        if (_newInfo.userLockedDGDStake >= get_uint_config(CONFIG_MINIMUM_LOCKED_DGD)) {\n            daoStakeStorage().addToParticipantList(msg.sender);\n            daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, currentQuarterIndex());\n        }\n\n        // interaction happens last\n        require(ERC20(dgdToken).transferFrom(msg.sender, address(this), _amount));\n        _success = true;\n    }\n\n    /**\n    @notice Function to withdraw DGD tokens from this contract (can only be withdrawn in the locking phase of quarter)\n    @param _amount Number of DGD tokens to withdraw\n    @return {\n      \"_success\": \"Boolean, true if the withdrawal was successful, revert otherwise\"\n    }\n    */\n    function withdrawDGD(uint256 _amount)\n        public\n        ifGlobalRewardsSet(currentQuarterIndex())\n        returns (bool _success)\n    {\n        require(isLockingPhase() || daoUpgradeStorage().isReplacedByNewDao());\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        StakeInformation memory _newInfo = refreshDGDStake(msg.sender, _info, false);\n\n        require(_info.userActualLockedDGD >= _amount);\n        _newInfo.userActualLockedDGD = _newInfo.userActualLockedDGD.sub(_amount);\n        _newInfo.userLockedDGDStake = _newInfo.userLockedDGDStake.sub(_amount);\n        _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.sub(_amount);\n\n        refreshModeratorStatus(msg.sender, _info, _newInfo);\n        // This has to happen at least once before user can participate in next quarter\n        daoRewardsManager().updateRewardsBeforeNewQuarter(msg.sender);\n\n        if (_newInfo.userLockedDGDStake < get_uint_config(CONFIG_MINIMUM_LOCKED_DGD)) {\n            daoStakeStorage().removeFromParticipantList(msg.sender);\n        } else {\n            daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, currentQuarterIndex());\n        }\n\n        daoStakeStorage().updateUserDGDStake(msg.sender, _newInfo.userActualLockedDGD, _newInfo.userLockedDGDStake);\n        daoStakeStorage().updateTotalLockedDGDStake(_newInfo.totalLockedDGDStake);\n\n        require(ERC20(dgdToken).transfer(msg.sender, _amount));\n        _success = true;\n    }\n\n    /**\n    @notice Function to be called by someone who doesnt change their DGDStake for the next quarter to confirm that they're participating\n    @dev This can be done in the middle of the quarter as well\n    */\n    function confirmContinuedParticipation()\n        public\n        ifGlobalRewardsSet(currentQuarterIndex())\n    {\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        daoRewardsManager().updateRewardsBeforeNewQuarter(msg.sender);\n        StakeInformation memory _infoAfter = refreshDGDStake(msg.sender, _info, true);\n        refreshModeratorStatus(msg.sender, _info, _infoAfter);\n        daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, currentQuarterIndex());\n    }\n\n    /**\n    @notice This function refreshes the DGD stake of a user before continuing participation next quarter\n    @dev This has no difference if called in the lastParticipatedQuarter\n    */\n    function refreshDGDStake(address _user, StakeInformation _infoBefore, bool _saveToStorage)\n        internal\n        returns (StakeInformation memory _infoAfter)\n    {\n        _infoAfter.userLockedDGDStake = _infoBefore.userLockedDGDStake;\n        _infoAfter.userActualLockedDGD = _infoBefore.userActualLockedDGD;\n        _infoAfter.totalLockedDGDStake = _infoBefore.totalLockedDGDStake;\n\n        // only need to refresh if this is the first refresh in this new quarter;\n        uint256 _currentQuarter = currentQuarterIndex();\n        if (daoRewardsStorage().lastParticipatedQuarter(_user) < _currentQuarter) {\n            _infoAfter.userLockedDGDStake = daoCalculatorService().calculateAdditionalLockedDGDStake(_infoBefore.userActualLockedDGD);\n\n            _infoAfter.totalLockedDGDStake = _infoAfter.totalLockedDGDStake.add(\n                _infoAfter.userLockedDGDStake.sub(_infoBefore.userLockedDGDStake)\n            );\n            if (_saveToStorage) {\n                daoStakeStorage().updateUserDGDStake(_user, _infoAfter.userActualLockedDGD, _infoAfter.userLockedDGDStake);\n                daoStakeStorage().updateTotalLockedDGDStake(_infoAfter.totalLockedDGDStake);\n            }\n        }\n    }\n\n    /**\n    @notice This function refreshes the Moderator status of a user\n    @dev This takes the refreshed StakeInformation from refreshDGDStake as input\n    */\n    function refreshModeratorStatus(address _user, StakeInformation _infoBefore, StakeInformation _infoAfter)\n        internal\n    {\n        // remove from moderator list if conditions not satisfied\n        if (daoStakeStorage().isInModeratorsList(_user) == true) {\n\n            if (_infoAfter.userLockedDGDStake < get_uint_config(CONFIG_MINIMUM_DGD_FOR_MODERATOR) ||\n                daoPointsStorage().getReputation(_user) < get_uint_config(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR)) {\n\n                    daoStakeStorage().removeFromModeratorList(_user);\n                    daoStakeStorage().updateTotalModeratorLockedDGDs(\n                        daoStakeStorage().totalModeratorLockedDGDStake().sub(_infoBefore.userLockedDGDStake)\n                    );\n            } else { // update if everything is the same (but may not have locked in locking phase, so actual !== effective)\n                daoStakeStorage().updateTotalModeratorLockedDGDs(\n                    daoStakeStorage().totalModeratorLockedDGDStake().sub(_infoBefore.userLockedDGDStake).add(_infoAfter.userLockedDGDStake)\n                );\n            }\n        } else { // add to moderator list if conditions satisfied\n            if (_infoAfter.userLockedDGDStake >= get_uint_config(CONFIG_MINIMUM_DGD_FOR_MODERATOR) &&\n                daoPointsStorage().getReputation(_user) >= get_uint_config(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR)) {\n\n                    daoStakeStorage().addToModeratorList(_user);\n                    daoStakeStorage().updateTotalModeratorLockedDGDs(\n                        daoStakeStorage().totalModeratorLockedDGDStake().add(_infoAfter.userLockedDGDStake)\n                    );\n            }\n        }\n    }\n\n    function getStakeInformation(address _user)\n        internal\n        constant\n        returns (StakeInformation _info)\n    {\n        (_info.userActualLockedDGD, _info.userLockedDGDStake) = daoStakeStorage().readUserDGDStake(_user);\n        _info.totalLockedDGDStake = daoStakeStorage().totalLockedDGDStake();\n    }\n}\n","abiDocs":[{"constant":true,"inputs":[],"name":"resolver","payable":false,"stateMutability":"view","type":"function","signature":"resolver()","signatureHash":"04f3bcec"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","payable":false,"stateMutability":"view","type":"function","signature":"currentQuarterIndex()","signatureHash":"0d7cc561"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256","description":"Number of DGDs to lock"}],"name":"lockDGD","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if the locking process is successful, false otherwise"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Users must `approve` the DaoStakeLocking contract to transfer DGDs from them","return":"{ \"_success\": \"Boolean, true if the locking process is successful, false otherwise\" }","notice":"Function to lock DGD tokens to participate in the DAO","signature":"lockDGD(uint256)","signatureHash":"14efcd3c"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","payable":false,"stateMutability":"view","type":"function","signature":"get_address_config(bytes32)","signatureHash":"19e971eb"},{"constant":true,"inputs":[],"name":"dgdBadgeToken","payable":false,"stateMutability":"view","type":"function","signature":"dgdBadgeToken()","signatureHash":"1b1e53ef"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","payable":false,"stateMutability":"view","type":"function","signature":"get_bytes_config(bytes32)","signatureHash":"217f2412"},{"constant":true,"inputs":[],"name":"key","payable":false,"stateMutability":"view","type":"function","signature":"key()","signatureHash":"3943380c"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32","description":"the resolver key to look up"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address","description":"the address of the contract"}],"payable":false,"stateMutability":"view","type":"function","details":"Get the address of a contract","return":"_contract the address of the contract","signature":"get_contract(bytes32)","signatureHash":"3f83acff"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","payable":false,"stateMutability":"view","type":"function","signature":"get_uint_config(bytes32)","signatureHash":"46b56321"},{"constant":true,"inputs":[],"name":"currentTInQuarter","payable":false,"stateMutability":"view","type":"function","signature":"currentTInQuarter()","signatureHash":"61645b87"},{"constant":false,"inputs":[],"name":"confirmContinuedParticipation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This can be done in the middle of the quarter as well","notice":"Function to be called by someone who doesnt change their DGDStake for the next quarter to confirm that they're participating","signature":"confirmContinuedParticipation()","signatureHash":"74cd7f6d"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","payable":false,"stateMutability":"view","type":"function","signature":"isParticipant(address)","signatureHash":"929066f5"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256","description":"Number of DGD tokens to withdraw"}],"name":"withdrawDGD","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if the withdrawal was successful, revert otherwise"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"{ \"_success\": \"Boolean, true if the withdrawal was successful, revert otherwise\" }","notice":"Function to withdraw DGD tokens from this contract (can only be withdrawn in the locking phase of quarter)","signature":"withdrawDGD(uint256)","signatureHash":"963cdbfd"},{"constant":true,"inputs":[],"name":"dgdToken","payable":false,"stateMutability":"view","type":"function","signature":"dgdToken()","signatureHash":"be6999c4"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","payable":false,"stateMutability":"view","type":"function","signature":"CONTRACT_ADDRESS()","signatureHash":"db4ecbc1"},{"constant":false,"inputs":[],"name":"redeemBadge","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Only 1 DGD Badge is accepted from an address, so multiple badge holders should either sell their other badges or redeem reputation to another address","notice":"Function to initially convert DGD Badge to Reputation Points","signature":"redeemBadge()","signatureHash":"dda249f5"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","payable":false,"stateMutability":"view","type":"function","signature":"isProposalPaused(bytes32)","signatureHash":"f94f0f33"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","payable":false,"stateMutability":"view","type":"function","signature":"isModerator(address)","signatureHash":"fa6f3936"},{"inputs":[{"name":"_resolver","type":"address"},{"name":"_dgdToken","type":"address"},{"name":"_dgdBadgeToken","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]}
