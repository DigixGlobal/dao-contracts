{"author":"Digix Holdings","title":"Contract to manage DGX rewards","fileName":"/contracts/interactive/DaoRewardsManager.sol","name":"DaoRewardsManager","abi":[{"constant":true,"inputs":[],"name":"resolver","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ADDRESS_DGX_TOKEN","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","outputs":[{"name":"_quarterIndex","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","outputs":[{"name":"_config_value","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","outputs":[{"name":"_config_value","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"claimRewards","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"key","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","outputs":[{"name":"_config_value","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"currentTInQuarter","outputs":[{"name":"_currentT","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_operations","type":"uint256"}],"name":"calculateGlobalRewardsBeforeNewQuarter","outputs":[{"name":"_done","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_user","type":"address"}],"name":"updateRewardsBeforeNewQuarter","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_resolver","type":"address"},{"name":"_dgxAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.24;\n\nimport \"@digix/cacp-contracts-dao/contracts/ResolverClient.sol\";\nimport \"../common/DaoCommon.sol\";\nimport \"../lib/DaoStructs.sol\";\nimport \"../service/DaoCalculatorService.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\n/**\n@title Contract to manage DGX rewards\n@author Digix Holdings\n*/\ncontract DaoRewardsManager is DaoCommon {\n    using MathHelper for MathHelper;\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\n    using DaoStructs for DaoStructs.IntermediateResults;\n\n    address public ADDRESS_DGX_TOKEN;\n\n    struct UserRewards {\n        uint256 lastParticipatedQuarter;\n        uint256 lastQuarterThatRewardsWasUpdated;\n        DaoStructs.DaoQuarterInfo qInfo;\n        uint256 effectiveDGDBalance;\n        uint256 effectiveModeratorDGDBalance;\n    }\n\n    struct QuarterRewardsInfo {\n        uint256 previousQuarter;\n        uint256 totalEffectiveDGDLastQuarter;\n        bool doneCalculatingEffectiveBalance;\n        bool doneCalculatingModeratorEffectiveBalance;\n        uint256 totalEffectiveModeratorDGDLastQuarter;\n        uint256 dgxRewardsPoolLastQuarter;\n        DaoStructs.DaoQuarterInfo qInfo;\n        address currentUser;\n        uint256 userCount;\n        uint256 i;\n        address[] users;\n    }\n\n    function daoCalculatorService()\n        internal\n        constant\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    /**\n    @notice Constructor (set the quarter info for the first quarter)\n    @param _resolver Address of the Contract Resolver contract\n    @param _dgxAddress Address of the Digix Gold Token contract\n    */\n    constructor(address _resolver, address _dgxAddress)\n        public\n    {\n        require(init(CONTRACT_DAO_REWARDS_MANAGER, _resolver));\n        ADDRESS_DGX_TOKEN = _dgxAddress;\n        daoRewardsStorage().updateQuarterInfo(\n            1,\n            get_uint_config(CONFIG_MINIMAL_PARTICIPATION_POINT),\n            get_uint_config(CONFIG_QUARTER_POINT_SCALING_FACTOR),\n            get_uint_config(CONFIG_REPUTATION_POINT_SCALING_FACTOR),\n            0,\n            get_uint_config(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n            get_uint_config(CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR),\n            get_uint_config(CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR),\n            0,\n            now,\n            0,\n            0\n        );\n    }\n\n    /**\n    @notice Function to claim the DGX rewards allocated to user\n    @dev Will revert if _claimableDGX <= MINIMUM_TRANSFER_AMOUNT of DGX\n    */\n    function claimRewards()\n        public\n    {\n        address _user = msg.sender;\n        uint256 _claimableDGX;\n\n        // update rewards for the quarter that he last participated in\n        (, _claimableDGX) = calculateUserRewardsLastQuarter(_user);\n\n        // withdraw from his claimableDGXs\n        // This has to take into account demurrage\n        // Basically, the value of claimableDGXs in the contract is for the dgxDistributionDay of (lastParticipatedQuarter + 1)\n        uint256 _days_elapsed = now\n            .sub(\n                daoRewardsStorage().readDgxDistributionDay(\n                    daoRewardsStorage().lastQuarterThatRewardsWasUpdated(_user).add(1)\n                )\n            )\n            .div(1 days);\n\n        _claimableDGX = _claimableDGX.sub(\n            daoCalculatorService().calculateDemurrage(\n                _claimableDGX,\n                _days_elapsed\n            ));\n\n        daoRewardsStorage().addToTotalDgxClaimed(_claimableDGX);\n        daoRewardsStorage().updateClaimableDGX(_user, 0);\n        ERC20(ADDRESS_DGX_TOKEN).transfer(_user, _claimableDGX);\n    }\n\n    /**\n    @notice Function to update DGX rewards of user while locking/withdrawing DGDs, or continuing participation for new quarter\n    @param _user Address of the DAO participant\n    */\n    function updateRewardsBeforeNewQuarter(address _user)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        uint256 _currentQuarter = currentQuarterIndex();\n        // do nothing if the rewards was already updated for the previous quarter\n        if (daoRewardsStorage().lastQuarterThatRewardsWasUpdated(_user).add(1) >= _currentQuarter) {\n            return;\n        }\n        calculateUserRewardsLastQuarter(_user);\n        calculateUserReputationLastQuarter(_user);\n    }\n\n    function calculateUserReputationLastQuarter (address _user)\n        private\n    {\n        uint256 _lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(_user);\n        uint256 _lastQuarterThatReputationWasUpdated = daoRewardsStorage().lastQuarterThatReputationWasUpdated(_user);\n        uint256 _reputationDeduction;\n        if (currentQuarterIndex() <= _lastParticipatedQuarter) {\n            return;\n        }\n\n        if (_lastQuarterThatReputationWasUpdated == _lastParticipatedQuarter.sub(1)) {\n            updateRPfromQP(\n                _user,\n                daoPointsStorage().getQuarterPoint(_user, _lastParticipatedQuarter),\n                get_uint_config(CONFIG_MINIMAL_PARTICIPATION_POINT),\n                get_uint_config(CONFIG_MAXIMUM_REPUTATION_DEDUCTION),\n                get_uint_config(CONFIG_REPUTATION_PER_EXTRA_QP_NUM),\n                get_uint_config(CONFIG_REPUTATION_PER_EXTRA_QP_DEN)\n            );\n\n            // this user is not a Moderator for current quarter\n            // coz this step is done before updating the refreshModerator.\n            // But may have been a Moderator before, and if was moderator in their\n            // lastParticipatedQuarter, we will find them in the DoublyLinkedList.\n            if (daoStakeStorage().isInModeratorsList(_user)) {\n                updateRPfromQP(\n                    _user,\n                    daoPointsStorage().getQuarterModeratorPoint(_user, _lastParticipatedQuarter),\n                    get_uint_config(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n                    get_uint_config(CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION),\n                    get_uint_config(CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM),\n                    get_uint_config(CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN)\n                );\n            }\n        }\n\n        _reputationDeduction =\n            (currentQuarterIndex().sub(1).sub(MathHelper.max(_lastParticipatedQuarter, _lastQuarterThatReputationWasUpdated)))\n            .mul(\n                get_uint_config(CONFIG_MAXIMUM_REPUTATION_DEDUCTION)\n                .add(get_uint_config(CONFIG_PUNISHMENT_FOR_NOT_LOCKING))\n            );\n\n        if (_reputationDeduction > 0) daoPointsStorage().subtractReputation(_user, _reputationDeduction);\n        daoRewardsStorage().updateLastQuarterThatReputationWasUpdated(_user, currentQuarterIndex().sub(1));\n    }\n\n    function updateRPfromQP (\n        address _user,\n        uint256 _userQP,\n        uint256 _minimalQP,\n        uint256 _maxRPDeduction,\n        uint256 _rpPerExtraQP_num,\n        uint256 _rpPerExtraQP_den\n    ) internal {\n        uint256 _reputationDeduction;\n        uint256 _reputationAddition;\n        if (_userQP < _minimalQP) {\n            _reputationDeduction =\n                _minimalQP.sub(_userQP)\n                .mul(_maxRPDeduction)\n                .div(_minimalQP);\n\n            daoPointsStorage().subtractReputation(_user, _reputationDeduction);\n        } else {\n            _reputationAddition =\n                _userQP.sub(_minimalQP)\n                .mul(_rpPerExtraQP_num)\n                .div(_rpPerExtraQP_den);\n\n            daoPointsStorage().addReputation(_user, _reputationAddition);\n        }\n    }\n\n    function calculateUserRewardsLastQuarter(address _user)\n        private\n        returns (bool _valid, uint256 _userClaimableDgx)\n    {\n        UserRewards memory data;\n        // the last participating quarter must be:\n        // - over\n        // - after the lastQuarterThatRewardsWasUpdated\n        data.lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(_user);\n        data.lastQuarterThatRewardsWasUpdated = daoRewardsStorage().lastQuarterThatRewardsWasUpdated(_user);\n\n        _userClaimableDgx = daoRewardsStorage().claimableDGXs(_user);\n        if (currentQuarterIndex() <= data.lastParticipatedQuarter || data.lastParticipatedQuarter <= data.lastQuarterThatRewardsWasUpdated) {\n            return (false, _userClaimableDgx);\n        }\n\n        // now we will calculate the user rewards based on info of the data.lastParticipatedQuarter\n        data.qInfo = readQuarterInfo(data.lastParticipatedQuarter);\n\n        // now we \"deduct the demurrage\" from the claimable DGXs for time period from\n        // dgxDistributionDay of lastQuarterThatRewardsWasUpdated + 1 to dgxDistributionDay of lastParticipatedQuarter + 1\n        uint256 _days_elapsed = daoRewardsStorage().readDgxDistributionDay(data.lastParticipatedQuarter.add(1))\n            .sub(daoRewardsStorage().readDgxDistributionDay(data.lastQuarterThatRewardsWasUpdated.add(1)))\n            .div(1 days);\n        _userClaimableDgx = _userClaimableDgx.sub(\n            daoCalculatorService().calculateDemurrage(\n                _userClaimableDgx,\n                _days_elapsed\n            )\n        );\n\n        // RP has been updated at the beginning of the lastParticipatedQuarter in\n        // a call to updateRewardsBeforeNewQuarter();\n\n        // calculate dgx rewards; This is basically the DGXs that user can withdraw on the dgxDistributionDay of the last participated quarter\n        // when user actually withdraw some time after that, he will be deducted demurrage.\n\n        data.effectiveDGDBalance = daoCalculatorService().calculateUserEffectiveBalance(\n            data.qInfo.minimalParticipationPoint,\n            data.qInfo.quarterPointScalingFactor,\n            data.qInfo.reputationPointScalingFactor,\n            daoPointsStorage().getQuarterPoint(_user, data.lastParticipatedQuarter),\n            daoPointsStorage().getReputation(_user),\n            daoStakeStorage().lockedDGDStake(_user)\n        );\n\n        data.effectiveModeratorDGDBalance = daoCalculatorService().calculateUserEffectiveBalance(\n            data.qInfo.moderatorMinimalParticipationPoint,\n            data.qInfo.moderatorQuarterPointScalingFactor,\n            data.qInfo.moderatorReputationPointScalingFactor,\n            daoPointsStorage().getQuarterModeratorPoint(_user, data.lastParticipatedQuarter),\n            daoPointsStorage().getReputation(_user),\n            daoStakeStorage().lockedDGDStake(_user)\n        );\n\n        if (daoRewardsStorage().readTotalEffectiveDGDLastQuarter(data.lastParticipatedQuarter.add(1)) > 0) {\n            _userClaimableDgx = _userClaimableDgx.add(\n                data.effectiveDGDBalance\n                .mul(daoRewardsStorage().readRewardsPoolOfLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .mul(\n                    get_uint_config(CONFIG_PORTION_TO_BADGE_HOLDERS_DEN)\n                    .sub(get_uint_config(CONFIG_PORTION_TO_BADGE_HOLDERS_NUM))\n                )\n                .div(daoRewardsStorage().readTotalEffectiveDGDLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .div(get_uint_config(CONFIG_PORTION_TO_BADGE_HOLDERS_DEN))\n            );\n        }\n\n        if (daoRewardsStorage().readTotalEffectiveModeratorDGDLastQuarter(data.lastParticipatedQuarter.add(1)) > 0) {\n            _userClaimableDgx = _userClaimableDgx.add(\n                data.effectiveModeratorDGDBalance\n                .mul(daoRewardsStorage().readRewardsPoolOfLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .mul(\n                     get_uint_config(CONFIG_PORTION_TO_BADGE_HOLDERS_NUM)\n                )\n                .div(daoRewardsStorage().readTotalEffectiveModeratorDGDLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .div(get_uint_config(CONFIG_PORTION_TO_BADGE_HOLDERS_DEN))\n            );\n        }\n\n        // update claimableDGXs. The calculation needs to take into account demurrage since the\n        // dgxDistributionDay of the last quarter as well\n        daoRewardsStorage().updateClaimableDGX(_user, _userClaimableDgx);\n\n        // update lastQuarterThatRewardsWasUpdated\n        daoRewardsStorage().updateLastQuarterThatRewardsWasUpdated(_user, data.lastParticipatedQuarter);\n        _valid = true;\n    }\n\n    /**\n    @notice Function called by the founder after transfering the DGX fees into the DAO at the beginning of the quarter\n    */\n    function calculateGlobalRewardsBeforeNewQuarter(uint256 _operations)\n        if_founder()\n        public\n        returns (bool _done)\n    {\n        require(isDaoNotReplaced());\n        require(isLockingPhase());\n        QuarterRewardsInfo memory info;\n        info.previousQuarter = currentQuarterIndex().sub(1);\n        require(info.previousQuarter > 0); // throw if this is the first quarter\n        info.qInfo = readQuarterInfo(info.previousQuarter);\n\n        DaoStructs.IntermediateResults memory interResults;\n        (\n            interResults.countedUntil,,,,\n            info.totalEffectiveDGDLastQuarter\n        ) = intermediateResultsStorage().getIntermediateResults(keccak256(abi.encodePacked(INTERMEDIATE_DGD_IDENTIFIER, info.previousQuarter)));\n\n        _operations = sumEffectiveBalance(info, false, _operations, interResults);\n        if (!info.doneCalculatingEffectiveBalance) { return false; }\n\n        (\n            interResults.countedUntil,,,,\n            info.totalEffectiveModeratorDGDLastQuarter\n        ) = intermediateResultsStorage().getIntermediateResults(keccak256(abi.encodePacked(INTERMEDIATE_MODERATOR_DGD_IDENTIFIER, info.previousQuarter)));\n\n        sumEffectiveBalance(info, true, _operations, interResults);\n        if (!info.doneCalculatingModeratorEffectiveBalance) { return false; }\n        // save the quarter Info\n        processGlobalRewardsUpdate(info);\n        _done = true;\n    }\n\n    function processGlobalRewardsUpdate(QuarterRewardsInfo memory info) internal {\n        // calculate how much DGX rewards we got for this quarter\n        info.dgxRewardsPoolLastQuarter =\n            ERC20(ADDRESS_DGX_TOKEN).balanceOf(address(this))\n            .add(daoRewardsStorage().totalDGXsClaimed())\n            .sub(info.qInfo.sumRewardsFromBeginning);\n\n        daoRewardsStorage().updateQuarterInfo(\n            info.previousQuarter.add(1),\n            get_uint_config(CONFIG_MINIMAL_PARTICIPATION_POINT),\n            get_uint_config(CONFIG_QUARTER_POINT_SCALING_FACTOR),\n            get_uint_config(CONFIG_REPUTATION_POINT_SCALING_FACTOR),\n            info.totalEffectiveDGDLastQuarter,\n\n            get_uint_config(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n            get_uint_config(CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR),\n            get_uint_config(CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR),\n            info.totalEffectiveModeratorDGDLastQuarter,\n\n            now,\n            info.dgxRewardsPoolLastQuarter,\n            info.qInfo.sumRewardsFromBeginning.add(info.dgxRewardsPoolLastQuarter)\n        );\n    }\n\n    function sumEffectiveBalance (\n        QuarterRewardsInfo memory info,\n        bool _badgeCalculation,\n        uint256 _operations,\n        DaoStructs.IntermediateResults memory _interResults\n    )\n        internal\n        returns (uint _operationsLeft)\n    {\n        if (_operations == 0) return _operations;\n\n        if (_interResults.countedUntil == EMPTY_ADDRESS) {\n            info.users = _badgeCalculation ?\n                daoListingService().listModerators(_operations, true)\n                : daoListingService().listParticipants(_operations, true);\n        } else {\n            info.users = _badgeCalculation ?\n                daoListingService().listModeratorsFrom(_interResults.countedUntil, _operations, true)\n                : daoListingService().listParticipantsFrom(_interResults.countedUntil, _operations, true);\n\n            // if the address is the already the last, it means this is the first step, and its already done;\n            if (info.users.length == 0) {\n                info.doneCalculatingEffectiveBalance = true;\n                return _operations;\n            }\n        }\n\n        address _lastAddress;\n        _lastAddress = info.users[info.users.length - 1];\n\n        info.userCount = info.users.length;\n        for (info.i=0;info.i<info.userCount;info.i++) {\n            info.currentUser = info.users[info.i];\n            // check if this participant really did participate in the previous quarter\n            if (daoRewardsStorage().lastParticipatedQuarter(info.currentUser) < info.previousQuarter) {\n                continue;\n            }\n            if (_badgeCalculation) {\n                info.totalEffectiveModeratorDGDLastQuarter = info.totalEffectiveModeratorDGDLastQuarter.add(daoCalculatorService().calculateUserEffectiveBalance(\n                    info.qInfo.moderatorMinimalParticipationPoint,\n                    info.qInfo.moderatorQuarterPointScalingFactor,\n                    info.qInfo.moderatorReputationPointScalingFactor,\n                    daoPointsStorage().getQuarterModeratorPoint(info.currentUser, info.previousQuarter),\n                    daoPointsStorage().getReputation(info.currentUser),\n                    daoStakeStorage().lockedDGDStake(info.currentUser)\n                ));\n            } else {\n                info.totalEffectiveDGDLastQuarter = info.totalEffectiveDGDLastQuarter.add(daoCalculatorService().calculateUserEffectiveBalance(\n                    info.qInfo.minimalParticipationPoint,\n                    info.qInfo.quarterPointScalingFactor,\n                    info.qInfo.reputationPointScalingFactor,\n                    daoPointsStorage().getQuarterPoint(info.currentUser, info.previousQuarter),\n                    daoPointsStorage().getReputation(info.currentUser),\n                    daoStakeStorage().lockedDGDStake(info.currentUser)\n                ));\n            }\n        }\n\n        // check if we have reached the last guy in the current list\n        if (_lastAddress == daoStakeStorage().readLastModerator() && _badgeCalculation) {\n            info.doneCalculatingModeratorEffectiveBalance = true;\n        }\n        if (_lastAddress == daoStakeStorage().readLastParticipant() && !_badgeCalculation) {\n            info.doneCalculatingEffectiveBalance = true;\n        }\n        intermediateResultsStorage().setIntermediateResults(\n            keccak256(abi.encodePacked(_badgeCalculation ? INTERMEDIATE_MODERATOR_DGD_IDENTIFIER : INTERMEDIATE_DGD_IDENTIFIER, info.previousQuarter)),\n            _lastAddress,\n            0,0,0,\n            _badgeCalculation ? info.totalEffectiveModeratorDGDLastQuarter : info.totalEffectiveDGDLastQuarter\n        );\n\n        _operationsLeft = _operations.sub(info.userCount);\n    }\n\n    function readQuarterInfo(uint256 _quarterIndex)\n        internal\n        constant\n        returns (DaoStructs.DaoQuarterInfo _qInfo)\n    {\n        (\n            _qInfo.minimalParticipationPoint,\n            _qInfo.quarterPointScalingFactor,\n            _qInfo.reputationPointScalingFactor,\n            _qInfo.totalEffectiveDGDLastQuarter\n        ) = daoRewardsStorage().readQuarterParticipantInfo(_quarterIndex);\n        (\n            _qInfo.moderatorMinimalParticipationPoint,\n            _qInfo.moderatorQuarterPointScalingFactor,\n            _qInfo.moderatorReputationPointScalingFactor,\n            _qInfo.totalEffectiveModeratorDGDLastQuarter\n        ) = daoRewardsStorage().readQuarterModeratorInfo(_quarterIndex);\n        (\n            _qInfo.dgxDistributionDay,\n            _qInfo.dgxRewardsPoolLastQuarter,\n            _qInfo.sumRewardsFromBeginning\n        ) = daoRewardsStorage().readQuarterGeneralInfo(_quarterIndex);\n    }\n}\n","abiDocs":[{"constant":true,"inputs":[],"name":"resolver","payable":false,"stateMutability":"view","type":"function","signature":"resolver()","signatureHash":"04f3bcec"},{"constant":true,"inputs":[],"name":"ADDRESS_DGX_TOKEN","payable":false,"stateMutability":"view","type":"function","signature":"ADDRESS_DGX_TOKEN()","signatureHash":"0d12144b"},{"constant":true,"inputs":[],"name":"currentQuarterIndex","payable":false,"stateMutability":"view","type":"function","signature":"currentQuarterIndex()","signatureHash":"0d7cc561"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_address_config","payable":false,"stateMutability":"view","type":"function","signature":"get_address_config(bytes32)","signatureHash":"19e971eb"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_bytes_config","payable":false,"stateMutability":"view","type":"function","signature":"get_bytes_config(bytes32)","signatureHash":"217f2412"},{"constant":false,"inputs":[],"name":"claimRewards","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Will revert if _claimableDGX <= MINIMUM_TRANSFER_AMOUNT of DGX","notice":"Function to claim the DGX rewards allocated to user","signature":"claimRewards()","signatureHash":"372500ab"},{"constant":true,"inputs":[],"name":"key","payable":false,"stateMutability":"view","type":"function","signature":"key()","signatureHash":"3943380c"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32","description":"the resolver key to look up"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address","description":"the address of the contract"}],"payable":false,"stateMutability":"view","type":"function","details":"Get the address of a contract","return":"_contract the address of the contract","signature":"get_contract(bytes32)","signatureHash":"3f83acff"},{"constant":true,"inputs":[{"name":"_config_key","type":"bytes32"}],"name":"get_uint_config","payable":false,"stateMutability":"view","type":"function","signature":"get_uint_config(bytes32)","signatureHash":"46b56321"},{"constant":true,"inputs":[],"name":"currentTInQuarter","payable":false,"stateMutability":"view","type":"function","signature":"currentTInQuarter()","signatureHash":"61645b87"},{"constant":false,"inputs":[{"name":"_operations","type":"uint256"}],"name":"calculateGlobalRewardsBeforeNewQuarter","payable":false,"stateMutability":"nonpayable","type":"function","notice":"Function called by the founder after transfering the DGX fees into the DAO at the beginning of the quarter","signature":"calculateGlobalRewardsBeforeNewQuarter(uint256)","signatureHash":"7bf4a98d"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","payable":false,"stateMutability":"view","type":"function","signature":"isParticipant(address)","signatureHash":"929066f5"},{"constant":false,"inputs":[{"name":"_user","type":"address","description":"Address of the DAO participant"}],"name":"updateRewardsBeforeNewQuarter","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Function to update DGX rewards of user while locking/withdrawing DGDs, or continuing participation for new quarter","signature":"updateRewardsBeforeNewQuarter(address)","signatureHash":"aa2f2c05"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","payable":false,"stateMutability":"view","type":"function","signature":"CONTRACT_ADDRESS()","signatureHash":"db4ecbc1"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","payable":false,"stateMutability":"view","type":"function","signature":"isProposalPaused(bytes32)","signatureHash":"f94f0f33"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","payable":false,"stateMutability":"view","type":"function","signature":"isModerator(address)","signatureHash":"fa6f3936"},{"inputs":[{"name":"_resolver","type":"address"},{"name":"_dgxAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]}
