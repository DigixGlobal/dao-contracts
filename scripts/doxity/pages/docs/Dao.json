{"author":"Digix Holdings","title":"Interactive DAO contract for creating/modifying/endorsing proposals","fileName":"/contracts/interactive/Dao.sol","name":"Dao","abi":[{"constant":false,"inputs":[{"name":"_proposalIds","type":"bytes32[]"}],"name":"founderCloseProposals","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"resolver","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"closeProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getAddressConfig","outputs":[{"name":"_configValue","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_docIpfsHash","type":"bytes32"},{"name":"_milestonesFundings","type":"uint256[]"},{"name":"_finalReward","type":"uint256"}],"name":"submitPreproposal","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[],"name":"key","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_newDaoContract","type":"address"},{"name":"_newDaoFundingManager","type":"address"},{"name":"_newDaoRewardsManager","type":"address"}],"name":"migrateToNewDao","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"finalizeProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_milestoneIndex","type":"uint256"}],"name":"finishMilestone","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"currentTimeInQuarter","outputs":[{"name":"_currentT","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_start","type":"uint256"}],"name":"setStartOfFirstQuarter","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"isMainPhase","outputs":[{"name":"_isMainPhase","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_milestonesFundings","type":"uint256[]"},{"name":"_finalReward","type":"uint256"},{"name":"_currentMilestone","type":"uint256"}],"name":"changeFundings","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"isLockingPhase","outputs":[{"name":"_isLockingPhase","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_action","type":"uint256"},{"name":"_doc","type":"bytes32"}],"name":"updatePRL","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"currentQuarterNumber","outputs":[{"name":"_quarterNumber","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"endorseProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getBytesConfig","outputs":[{"name":"_configValue","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getUintConfig","outputs":[{"name":"_configValue","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_newDaoContract","type":"address"},{"name":"_newDaoFundingManager","type":"address"},{"name":"_newDaoRewardsManager","type":"address"}],"name":"setNewDaoContracts","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_docIpfsHash","type":"bytes32"},{"name":"_milestonesFundings","type":"uint256[]"},{"name":"_finalReward","type":"uint256"}],"name":"modifyProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"isDaoNotReplaced","outputs":[{"name":"_isNotReplaced","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32"},{"name":"_newDoc","type":"bytes32"}],"name":"addProposalDoc","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","outputs":[{"name":"_isPausedOrStopped","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","outputs":[{"name":"_is","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_resolver","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_proposer","type":"address"}],"name":"NewProposal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_newDoc","type":"bytes32"}],"name":"ModifyProposal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"ChangeProposalFunding","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"FinalizeProposal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":true,"name":"_milestoneIndex","type":"uint256"}],"name":"FinishMilestone","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_newDoc","type":"bytes32"}],"name":"AddProposalDoc","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_actionId","type":"uint256"},{"indexed":false,"name":"_doc","type":"bytes32"}],"name":"PRLAction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"CloseProposal","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_newDaoContract","type":"address"},{"indexed":false,"name":"_newDaoFundingManager","type":"address"},{"indexed":false,"name":"_newDaoRewardsManager","type":"address"}],"name":"MigrateToNewDao","type":"event"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.25;\n\nimport \"../common/DaoCommon.sol\";\nimport \"./DaoFundingManager.sol\";\nimport \"./DaoRewardsManager.sol\";\nimport \"./DaoVotingClaims.sol\";\n\n/**\n@title Interactive DAO contract for creating/modifying/endorsing proposals\n@author Digix Holdings\n*/\ncontract Dao is DaoCommon {\n\n    event NewProposal(bytes32 indexed _proposalId, address _proposer);\n    event ModifyProposal(bytes32 indexed _proposalId, bytes32 _newDoc);\n    event ChangeProposalFunding(bytes32 indexed _proposalId);\n    event FinalizeProposal(bytes32 indexed _proposalId);\n    event FinishMilestone(bytes32 indexed _proposalId, uint256 indexed _milestoneIndex);\n    event AddProposalDoc(bytes32 indexed _proposalId, bytes32 _newDoc);\n    event PRLAction(bytes32 indexed _proposalId, uint256 _actionId, bytes32 _doc);\n    event CloseProposal(bytes32 indexed _proposalId);\n    event MigrateToNewDao(address _newDaoContract, address _newDaoFundingManager, address _newDaoRewardsManager);\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_DAO, _resolver));\n    }\n\n    function daoFundingManager()\n        internal\n        view\n        returns (DaoFundingManager _contract)\n    {\n        _contract = DaoFundingManager(get_contract(CONTRACT_DAO_FUNDING_MANAGER));\n    }\n\n    function daoRewardsManager()\n        internal\n        view\n        returns (DaoRewardsManager _contract)\n    {\n        _contract = DaoRewardsManager(get_contract(CONTRACT_DAO_REWARDS_MANAGER));\n    }\n\n    function daoVotingClaims()\n        internal\n        view\n        returns (DaoVotingClaims _contract)\n    {\n        _contract = DaoVotingClaims(get_contract(CONTRACT_DAO_VOTING_CLAIMS));\n    }\n\n    /**\n    @notice Set addresses for the new Dao and DaoFundingManager contracts\n    @dev This is the first step of the 2-step migration\n    @param _newDaoContract Address of the new Dao contract\n    @param _newDaoFundingManager Address of the new DaoFundingManager contract\n    @param _newDaoRewardsManager Address of the new daoRewardsManager contract\n    */\n    function setNewDaoContracts(\n        address _newDaoContract,\n        address _newDaoFundingManager,\n        address _newDaoRewardsManager\n    )\n        public\n        if_root()\n    {\n        require(daoUpgradeStorage().isReplacedByNewDao() == false);\n        daoUpgradeStorage().setNewContractAddresses(\n            _newDaoContract,\n            _newDaoFundingManager,\n            _newDaoRewardsManager\n        );\n    }\n\n    /**\n    @notice Migrate this DAO to a new DAO contract\n    @dev This is the second step of the 2-step migration\n         Migration can only be done during the locking phase, after the global rewards for current quarter are set.\n         This is to make sure that there is no rewards calculation pending before the DAO is migrated to new contracts\n         The addresses of the new Dao contracts have to be provided again, and be double checked against the addresses that were set in setNewDaoContracts()\n    @param _newDaoContract Address of the new DAO contract\n    @param _newDaoFundingManager Address of the new DaoFundingManager contract, which would receive the remaining ETHs in this DaoFundingManager\n    @param _newDaoRewardsManager Address of the new daoRewardsManager contract, which would receive the claimableDGXs from this daoRewardsManager\n    */\n    function migrateToNewDao(\n        address _newDaoContract,\n        address _newDaoFundingManager,\n        address _newDaoRewardsManager\n    )\n        public\n        if_root()\n        ifGlobalRewardsSet(currentQuarterNumber())\n    {\n        require(isLockingPhase());\n        require(daoUpgradeStorage().isReplacedByNewDao() == false);\n        require(\n          (daoUpgradeStorage().newDaoContract() == _newDaoContract) &&\n          (daoUpgradeStorage().newDaoFundingManager() == _newDaoFundingManager) &&\n          (daoUpgradeStorage().newDaoRewardsManager() == _newDaoRewardsManager)\n        );\n        daoUpgradeStorage().updateForDaoMigration();\n        daoFundingManager().moveFundsToNewDao(_newDaoFundingManager);\n        daoRewardsManager().moveDGXsToNewDao(_newDaoRewardsManager);\n        emit MigrateToNewDao(_newDaoContract, _newDaoFundingManager, _newDaoRewardsManager);\n    }\n\n    /**\n    @notice Call this function to mark the start of the DAO's first quarter. This can only be done once, by a founder\n    @param _start Start time of the first quarter in the DAO\n    */\n    function setStartOfFirstQuarter(uint256 _start) public if_founder() {\n        require(daoUpgradeStorage().startOfFirstQuarter() == 0);\n        require(_start > 0);\n        daoUpgradeStorage().setStartOfFirstQuarter(_start);\n    }\n\n    /**\n    @notice Submit a new preliminary idea / Pre-proposal\n    @dev The proposer has to send in a collateral == getUintConfig(CONFIG_PREPROPOSAL_COLLATERAL)\n         which he could claim back in these scenarios:\n          - Before the proposal is finalized, by calling closeProposal()\n          - After all milestones are done and the final voting round is passed\n\n    @param _docIpfsHash Hash of the IPFS doc containing details of proposal\n    @param _milestonesFundings Array of fundings of the proposal milestones (in wei)\n    @param _finalReward Final reward asked by proposer at successful completion of all milestones of proposal\n    */\n    function submitPreproposal(\n        bytes32 _docIpfsHash,\n        uint256[] _milestonesFundings,\n        uint256 _finalReward\n    )\n        external\n        payable\n        ifFundingPossible(_milestonesFundings, _finalReward)\n    {\n        senderCanDoProposerOperations();\n        bool _isFounder = is_founder();\n\n        require(msg.value == getUintConfig(CONFIG_PREPROPOSAL_COLLATERAL));\n        require(address(daoFundingManager()).call.gas(25000).value(msg.value)());\n\n        checkNonDigixFundings(_milestonesFundings, _finalReward);\n\n        daoStorage().addProposal(_docIpfsHash, msg.sender, _milestonesFundings, _finalReward, _isFounder);\n        daoStorage().setProposalCollateralStatus(_docIpfsHash, COLLATERAL_STATUS_UNLOCKED);\n        daoStorage().setProposalCollateralAmount(_docIpfsHash, msg.value);\n\n        emit NewProposal(_docIpfsHash, msg.sender);\n    }\n\n    /**\n    @notice Modify a proposal (this can be done only before setting the final version)\n    @param _proposalId Proposal ID (hash of IPFS doc of the first version of the proposal)\n    @param _docIpfsHash Hash of IPFS doc of the modified version of the proposal\n    @param _milestonesFundings Array of fundings of the modified version of the proposal (in wei)\n    @param _finalReward Final reward on successful completion of all milestones of the modified version of proposal (in wei)\n    */\n    function modifyProposal(\n        bytes32 _proposalId,\n        bytes32 _docIpfsHash,\n        uint256[] _milestonesFundings,\n        uint256 _finalReward\n    )\n        external\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n\n        require(isEditable(_proposalId));\n        bytes32 _currentState;\n        (,,,_currentState,,,,,,) = daoStorage().readProposal(_proposalId);\n        require(_currentState == PROPOSAL_STATE_PREPROPOSAL ||\n          _currentState == PROPOSAL_STATE_DRAFT);\n\n        checkNonDigixFundings(_milestonesFundings, _finalReward);\n\n        daoStorage().editProposal(_proposalId, _docIpfsHash, _milestonesFundings, _finalReward);\n\n        emit ModifyProposal(_proposalId, _docIpfsHash);\n    }\n\n    /**\n    @notice Function to change the funding structure for a proposal\n    @dev Proposers can only change fundings for the subsequent milestones,\n    during the duration of an on-going milestone (so, cannot be before proposal finalization or during any voting phase)\n    @param _proposalId ID of the proposal\n    @param _milestonesFundings Array of fundings for milestones\n    @param _finalReward Final reward needed for completion of proposal\n    @param _currentMilestone the milestone number the proposal is currently in\n    */\n    function changeFundings(\n        bytes32 _proposalId,\n        uint256[] _milestonesFundings,\n        uint256 _finalReward,\n        uint256 _currentMilestone\n    )\n        external\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n\n        checkNonDigixFundings(_milestonesFundings, _finalReward);\n\n        uint256[] memory _currentFundings;\n        (_currentFundings,) = daoStorage().readProposalFunding(_proposalId);\n\n        // If there are N milestones, the milestone index must be < N. Otherwise, putting a milestone index of N will actually return a valid timestamp that is\n        // right after the final voting round (voting round index N is the final voting round)\n        // Which could be abused ( to add more milestones even after the final voting round)\n        require(_currentMilestone < _currentFundings.length);\n\n        uint256 _startOfCurrentMilestone = startOfMilestone(_proposalId, _currentMilestone);\n\n        // must be after the start of the milestone, and the milestone has not been finished yet (next voting hasnt started)\n        require(now > _startOfCurrentMilestone);\n        require(daoStorage().readProposalVotingTime(_proposalId, _currentMilestone.add(1)) == 0);\n\n        // can only modify the fundings after _currentMilestone\n        // so, all the fundings from 0 to _currentMilestone must be the same\n        for (uint256 i=0;i<=_currentMilestone;i++) {\n            require(_milestonesFundings[i] == _currentFundings[i]);\n        }\n\n        daoStorage().changeFundings(_proposalId, _milestonesFundings, _finalReward);\n\n        emit ChangeProposalFunding(_proposalId);\n    }\n\n    /**\n    @notice Finalize a proposal\n    @dev After finalizing a proposal, no more proposal version can be added. Proposer will only be able to change fundings and add more docs\n         Right after finalizing a proposal, the draft voting round starts. The proposer would also not be able to closeProposal() anymore\n         (hence, cannot claim back the collateral anymore, until the final voting round passes)\n    @param _proposalId ID of the proposal\n    */\n    function finalizeProposal(bytes32 _proposalId)\n        public\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n        require(isEditable(_proposalId));\n        checkNonDigixProposalLimit(_proposalId);\n\n        // make sure we have reasonably enough time left in the quarter to conduct the Draft Voting.\n        // Otherwise, the proposer must wait until the next quarter to finalize the proposal\n        require(getTimeLeftInQuarter(now) > getUintConfig(CONFIG_DRAFT_VOTING_PHASE).add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE)));\n        address _endorser;\n        (,,_endorser,,,,,,,) = daoStorage().readProposal(_proposalId);\n        require(_endorser != EMPTY_ADDRESS);\n        daoStorage().finalizeProposal(_proposalId);\n        daoStorage().setProposalDraftVotingTime(_proposalId, now);\n\n        emit FinalizeProposal(_proposalId);\n    }\n\n    /**\n    @notice Function to set milestone to be completed\n    @dev This can only be called in the Main Phase of DigixDAO by the proposer. It sets the\n         voting time for the next milestone, which is immediately, for most of the times. If there is not enough time left in the current\n         quarter, then the next voting is postponed to the start of next quarter\n    @param _proposalId ID of the proposal\n    @param _milestoneIndex Index of the milestone. Index starts from 0 (for the first milestone)\n    */\n    function finishMilestone(bytes32 _proposalId, uint256 _milestoneIndex)\n        public\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n\n        uint256[] memory _currentFundings;\n        (_currentFundings,) = daoStorage().readProposalFunding(_proposalId);\n\n        // If there are N milestones, the milestone index must be < N. Otherwise, putting a milestone index of N will actually return a valid timestamp that is\n        // right after the final voting round (voting round index N is the final voting round)\n        // Which could be abused ( to \"finish\" a milestone even after the final voting round)\n        require(_milestoneIndex < _currentFundings.length);\n\n        // must be after the start of this milestone, and the milestone has not been finished yet (voting hasnt started)\n        uint256 _startOfCurrentMilestone = startOfMilestone(_proposalId, _milestoneIndex);\n        require(now > _startOfCurrentMilestone);\n        require(daoStorage().readProposalVotingTime(_proposalId, _milestoneIndex.add(1)) == 0);\n\n        daoStorage().setProposalVotingTime(\n            _proposalId,\n            _milestoneIndex.add(1),\n            getTimelineForNextVote(_milestoneIndex.add(1), now)\n        ); // set the voting time of next voting\n\n        emit FinishMilestone(_proposalId, _milestoneIndex);\n    }\n\n    /**\n    @notice Add IPFS docs to a proposal\n    @dev This is allowed only after a proposal is finalized. Before finalizing\n         a proposal, proposer can modifyProposal and basically create a different ProposalVersion. After the proposal is finalized,\n         they can only allProposalDoc to the final version of that proposal\n    @param _proposalId ID of the proposal\n    @param _newDoc hash of the new IPFS doc\n    */\n    function addProposalDoc(bytes32 _proposalId, bytes32 _newDoc)\n        public\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n        bytes32 _finalVersion;\n        (,,,,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n        require(_finalVersion != EMPTY_BYTES);\n        daoStorage().addProposalDoc(_proposalId, _newDoc);\n\n        emit AddProposalDoc(_proposalId, _newDoc);\n    }\n\n    /**\n    @notice Function to endorse a pre-proposal (can be called only by DAO Moderator)\n    @param _proposalId ID of the proposal (hash of IPFS doc of the first version of the proposal)\n    */\n    function endorseProposal(bytes32 _proposalId)\n        public\n        isProposalState(_proposalId, PROPOSAL_STATE_PREPROPOSAL)\n    {\n        require(isMainPhase());\n        require(isModerator(msg.sender));\n        daoStorage().updateProposalEndorse(_proposalId, msg.sender);\n    }\n\n    /**\n    @notice Function to update the PRL (regulatory status) status of a proposal\n    @dev if a proposal is paused or stopped, the proposer wont be able to withdraw the funding\n    @param _proposalId ID of the proposal\n    @param _doc hash of IPFS uploaded document, containing details of PRL Action\n    */\n    function updatePRL(\n        bytes32 _proposalId,\n        uint256 _action,\n        bytes32 _doc\n    )\n        public\n        if_prl()\n    {\n        require(_action == PRL_ACTION_STOP || _action == PRL_ACTION_PAUSE || _action == PRL_ACTION_UNPAUSE);\n        daoStorage().updateProposalPRL(_proposalId, _action, _doc, now);\n\n        emit PRLAction(_proposalId, _action, _doc);\n    }\n\n    /**\n    @notice Function to close proposal (also get back collateral)\n    @dev Can only be closed if the proposal has not been finalized yet\n    @param _proposalId ID of the proposal\n    */\n    function closeProposal(bytes32 _proposalId)\n        public\n    {\n        senderCanDoProposerOperations();\n        require(isFromProposer(_proposalId));\n        bytes32 _finalVersion;\n        bytes32 _status;\n        (,,,_status,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n        require(_finalVersion == EMPTY_BYTES);\n        require(_status != PROPOSAL_STATE_CLOSED);\n        require(daoStorage().readProposalCollateralStatus(_proposalId) == COLLATERAL_STATUS_UNLOCKED);\n\n        daoStorage().closeProposal(_proposalId);\n        daoStorage().setProposalCollateralStatus(_proposalId, COLLATERAL_STATUS_CLAIMED);\n        emit CloseProposal(_proposalId);\n        require(daoFundingManager().refundCollateral(msg.sender, _proposalId));\n    }\n\n    /**\n    @notice Function for founders to close all the dead proposals\n    @dev Dead proposals = all proposals who are not yet finalized, and been there for more than the threshold time\n         The proposers of dead proposals will not get the collateral back\n    @param _proposalIds Array of proposal IDs\n    */\n    function founderCloseProposals(bytes32[] _proposalIds)\n        external\n        if_founder()\n    {\n        uint256 _length = _proposalIds.length;\n        uint256 _timeCreated;\n        bytes32 _finalVersion;\n        bytes32 _currentState;\n        for (uint256 _i = 0; _i < _length; _i++) {\n            (,,,_currentState,_timeCreated,,,_finalVersion,,) = daoStorage().readProposal(_proposalIds[_i]);\n            require(_finalVersion == EMPTY_BYTES);\n            require(\n                (_currentState == PROPOSAL_STATE_PREPROPOSAL) ||\n                (_currentState == PROPOSAL_STATE_DRAFT)\n            );\n            require(now > _timeCreated.add(getUintConfig(CONFIG_PROPOSAL_DEAD_DURATION)));\n            emit CloseProposal(_proposalIds[_i]);\n            daoStorage().closeProposal(_proposalIds[_i]);\n        }\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_proposalIds","type":"bytes32[]","description":"Array of proposal IDs"}],"name":"founderCloseProposals","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Dead proposals = all proposals who are not yet finalized, and been there for more than the threshold time The proposers of dead proposals will not get the collateral back","notice":"Function for founders to close all the dead proposals","signature":"founderCloseProposals(bytes32[])","signatureHash":"0247afe8"},{"constant":true,"inputs":[],"name":"resolver","payable":false,"stateMutability":"view","type":"function","signature":"resolver()","signatureHash":"04f3bcec"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"}],"name":"closeProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Can only be closed if the proposal has not been finalized yet","notice":"Function to close proposal (also get back collateral)","signature":"closeProposal(bytes32)","signatureHash":"078f872c"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getAddressConfig","payable":false,"stateMutability":"view","type":"function","signature":"getAddressConfig(bytes32)","signatureHash":"1d8ccd04"},{"constant":false,"inputs":[{"name":"_docIpfsHash","type":"bytes32","description":"Hash of the IPFS doc containing details of proposal"},{"name":"_milestonesFundings","type":"uint256[]","description":"Array of fundings of the proposal milestones (in wei)"},{"name":"_finalReward","type":"uint256","description":"Final reward asked by proposer at successful completion of all milestones of proposal"}],"name":"submitPreproposal","outputs":[],"payable":true,"stateMutability":"payable","type":"function","details":"The proposer has to send in a collateral == getUintConfig(CONFIG_PREPROPOSAL_COLLATERAL) which he could claim back in these scenarios: - Before the proposal is finalized, by calling closeProposal() - After all milestones are done and the final voting round is passed","notice":"Submit a new preliminary idea / Pre-proposal","signature":"submitPreproposal(bytes32,uint256[],uint256)","signatureHash":"2b847105"},{"constant":true,"inputs":[],"name":"key","payable":false,"stateMutability":"view","type":"function","signature":"key()","signatureHash":"3943380c"},{"constant":false,"inputs":[{"name":"_newDaoContract","type":"address","description":"Address of the new DAO contract"},{"name":"_newDaoFundingManager","type":"address","description":"Address of the new DaoFundingManager contract, which would receive the remaining ETHs in this DaoFundingManager"},{"name":"_newDaoRewardsManager","type":"address","description":"Address of the new daoRewardsManager contract, which would receive the claimableDGXs from this daoRewardsManager"}],"name":"migrateToNewDao","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This is the second step of the 2-step migration Migration can only be done during the locking phase, after the global rewards for current quarter are set. This is to make sure that there is no rewards calculation pending before the DAO is migrated to new contracts The addresses of the new Dao contracts have to be provided again, and be double checked against the addresses that were set in setNewDaoContracts()","notice":"Migrate this DAO to a new DAO contract","signature":"migrateToNewDao(address,address,address)","signatureHash":"3b00763d"},{"constant":true,"inputs":[{"name":"_key","type":"bytes32","description":"the resolver key to look up"}],"name":"get_contract","outputs":[{"name":"_contract","type":"address","description":"the address of the contract"}],"payable":false,"stateMutability":"view","type":"function","details":"Get the address of a contract","return":"_contract the address of the contract","signature":"get_contract(bytes32)","signatureHash":"3f83acff"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"}],"name":"finalizeProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"After finalizing a proposal, no more proposal version can be added. Proposer will only be able to change fundings and add more docs Right after finalizing a proposal, the draft voting round starts. The proposer would also not be able to closeProposal() anymore (hence, cannot claim back the collateral anymore, until the final voting round passes)","notice":"Finalize a proposal","signature":"finalizeProposal(bytes32)","signatureHash":"47d0da14"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_milestoneIndex","type":"uint256","description":"Index of the milestone. Index starts from 0 (for the first milestone)"}],"name":"finishMilestone","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This can only be called in the Main Phase of DigixDAO by the proposer. It sets the voting time for the next milestone, which is immediately, for most of the times. If there is not enough time left in the current quarter, then the next voting is postponed to the start of next quarter","notice":"Function to set milestone to be completed","signature":"finishMilestone(bytes32,uint256)","signatureHash":"55cc3136"},{"constant":true,"inputs":[],"name":"currentTimeInQuarter","outputs":[{"name":"_currentT","type":"uint256","description":"the current relative time in the quarter"}],"payable":false,"stateMutability":"view","type":"function","details":"For example: the currentTimeInQuarter of the first second of any quarter is 1","return":"_currentT the current relative time in the quarter","notice":"Get the current relative time in the quarter","signature":"currentTimeInQuarter()","signatureHash":"560a25ea"},{"constant":false,"inputs":[{"name":"_start","type":"uint256","description":"Start time of the first quarter in the DAO"}],"name":"setStartOfFirstQuarter","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Call this function to mark the start of the DAO's first quarter. This can only be done once, by a founder","signature":"setStartOfFirstQuarter(uint256)","signatureHash":"5b30f1cc"},{"constant":true,"inputs":[],"name":"isMainPhase","outputs":[{"name":"_isMainPhase","type":"bool","description":"true if it is in a main phase"}],"payable":false,"stateMutability":"view","type":"function","details":"The main phase is where all the governance activities could take plase. If the DAO is replaced, there can never be any more main phase.","return":"_isMainPhase true if it is in a main phase","notice":"Check if it is currently in a main phase.","signature":"isMainPhase()","signatureHash":"68533060"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_milestonesFundings","type":"uint256[]","description":"Array of fundings for milestones"},{"name":"_finalReward","type":"uint256","description":"Final reward needed for completion of proposal"},{"name":"_currentMilestone","type":"uint256","description":"the milestone number the proposal is currently in"}],"name":"changeFundings","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Proposers can only change fundings for the subsequent milestones, during the duration of an on-going milestone (so, cannot be before proposal finalization or during any voting phase)","notice":"Function to change the funding structure for a proposal","signature":"changeFundings(bytes32,uint256[],uint256,uint256)","signatureHash":"711f2614"},{"constant":true,"inputs":[],"name":"isLockingPhase","outputs":[{"name":"_isLockingPhase","type":"bool","description":"true if it is in the locking phase"}],"payable":false,"stateMutability":"view","type":"function","details":"No governance activities can happen in the locking phase. The locking phase is from t=0 to t=CONFIG_LOCKING_PHASE_DURATION-1","return":"_isLockingPhase true if it is in the locking phase","notice":"Check if it is currently in the locking phase","signature":"isLockingPhase()","signatureHash":"7d6fed80"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_action","type":"uint256"},{"name":"_doc","type":"bytes32","description":"hash of IPFS uploaded document, containing details of PRL Action"}],"name":"updatePRL","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"if a proposal is paused or stopped, the proposer wont be able to withdraw the funding","notice":"Function to update the PRL (regulatory status) status of a proposal","signature":"updatePRL(bytes32,uint256,bytes32)","signatureHash":"7ef37354"},{"constant":true,"inputs":[],"name":"currentQuarterNumber","outputs":[{"name":"_quarterNumber","type":"uint256","description":"the current quarter index"}],"payable":false,"stateMutability":"view","type":"function","details":"Quarter indexes starts from 1","return":"_quarterNumber the current quarter index","notice":"Get the current quarter index","signature":"currentQuarterNumber()","signatureHash":"7f6a26b6"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal (hash of IPFS doc of the first version of the proposal)"}],"name":"endorseProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Function to endorse a pre-proposal (can be called only by DAO Moderator)","signature":"endorseProposal(bytes32)","signatureHash":"926851af"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isParticipant","payable":false,"stateMutability":"view","type":"function","notice":"Check if a user is a participant in the current quarter","signature":"isParticipant(address)","signatureHash":"929066f5"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getBytesConfig","payable":false,"stateMutability":"view","type":"function","signature":"getBytesConfig(bytes32)","signatureHash":"93ddad08"},{"constant":true,"inputs":[{"name":"_configKey","type":"bytes32"}],"name":"getUintConfig","payable":false,"stateMutability":"view","type":"function","signature":"getUintConfig(bytes32)","signatureHash":"b1e2b9dd"},{"constant":false,"inputs":[{"name":"_newDaoContract","type":"address","description":"Address of the new Dao contract"},{"name":"_newDaoFundingManager","type":"address","description":"Address of the new DaoFundingManager contract"},{"name":"_newDaoRewardsManager","type":"address","description":"Address of the new daoRewardsManager contract"}],"name":"setNewDaoContracts","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This is the first step of the 2-step migration","notice":"Set addresses for the new Dao and DaoFundingManager contracts","signature":"setNewDaoContracts(address,address,address)","signatureHash":"b202cc96"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"Proposal ID (hash of IPFS doc of the first version of the proposal)"},{"name":"_docIpfsHash","type":"bytes32","description":"Hash of IPFS doc of the modified version of the proposal"},{"name":"_milestonesFundings","type":"uint256[]","description":"Array of fundings of the modified version of the proposal (in wei)"},{"name":"_finalReward","type":"uint256","description":"Final reward on successful completion of all milestones of the modified version of proposal (in wei)"}],"name":"modifyProposal","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","notice":"Modify a proposal (this can be done only before setting the final version)","signature":"modifyProposal(bytes32,bytes32,uint256[],uint256)","signatureHash":"d0bd65b1"},{"constant":true,"inputs":[],"name":"isDaoNotReplaced","outputs":[{"name":"_isNotReplaced","type":"bool","description":"true if it is not replaced, false if it has already been replaced"}],"payable":false,"stateMutability":"view","type":"function","return":"_isNotReplaced true if it is not replaced, false if it has already been replaced","notice":"Check if the DAO contracts have been replaced by a new set of contracts","signature":"isDaoNotReplaced()","signatureHash":"d70d9358"},{"constant":true,"inputs":[],"name":"CONTRACT_ADDRESS","payable":false,"stateMutability":"view","type":"function","signature":"CONTRACT_ADDRESS()","signatureHash":"db4ecbc1"},{"constant":false,"inputs":[{"name":"_proposalId","type":"bytes32","description":"ID of the proposal"},{"name":"_newDoc","type":"bytes32","description":"hash of the new IPFS doc"}],"name":"addProposalDoc","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This is allowed only after a proposal is finalized. Before finalizing a proposal, proposer can modifyProposal and basically create a different ProposalVersion. After the proposal is finalized, they can only allProposalDoc to the final version of that proposal","notice":"Add IPFS docs to a proposal","signature":"addProposalDoc(bytes32,bytes32)","signatureHash":"eef7b8f5"},{"constant":true,"inputs":[{"name":"_proposalId","type":"bytes32"}],"name":"isProposalPaused","outputs":[{"name":"_isPausedOrStopped","type":"bool","description":"true if the proposal is paused(or stopped)"}],"payable":false,"stateMutability":"view","type":"function","details":"If a proposal is paused/stopped (by the PRLs): proposer cannot call for voting, a current on-going voting round can still pass, but no funding can be withdrawn.A paused proposal can still be unpausedIf a proposal is stopped, this function also returns true","return":"_isPausedOrStopped true if the proposal is paused(or stopped)","notice":"Check if a proposal is currently paused/stopped","signature":"isProposalPaused(bytes32)","signatureHash":"f94f0f33"},{"constant":true,"inputs":[{"name":"_user","type":"address"}],"name":"isModerator","payable":false,"stateMutability":"view","type":"function","notice":"Check if a user is a moderator in the current quarter","signature":"isModerator(address)","signatureHash":"fa6f3936"},{"inputs":[{"name":"_resolver","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_proposer","type":"address"}],"name":"NewProposal","type":"event","signature":"NewProposal(bytes32,address)","signatureHash":"ab48f599"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_newDoc","type":"bytes32"}],"name":"ModifyProposal","type":"event","signature":"ModifyProposal(bytes32,bytes32)","signatureHash":"8ed872b5"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"ChangeProposalFunding","type":"event","signature":"ChangeProposalFunding(bytes32)","signatureHash":"c9e43761"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"FinalizeProposal","type":"event","signature":"FinalizeProposal(bytes32)","signatureHash":"7987ab68"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":true,"name":"_milestoneIndex","type":"uint256"}],"name":"FinishMilestone","type":"event","signature":"FinishMilestone(bytes32,uint256)","signatureHash":"7f575746"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_newDoc","type":"bytes32"}],"name":"AddProposalDoc","type":"event","signature":"AddProposalDoc(bytes32,bytes32)","signatureHash":"7e60a4e6"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"},{"indexed":false,"name":"_actionId","type":"uint256"},{"indexed":false,"name":"_doc","type":"bytes32"}],"name":"PRLAction","type":"event","signature":"PRLAction(bytes32,uint256,bytes32)","signatureHash":"75c2f2b4"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_proposalId","type":"bytes32"}],"name":"CloseProposal","type":"event","signature":"CloseProposal(bytes32)","signatureHash":"cc0c35dc"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_newDaoContract","type":"address"},{"indexed":false,"name":"_newDaoFundingManager","type":"address"},{"indexed":false,"name":"_newDaoRewardsManager","type":"address"}],"name":"MigrateToNewDao","type":"event","signature":"MigrateToNewDao(address,address,address)","signatureHash":"bdee2a20"}]}
